




### термины
| термин               | значение      | пример |  
|-- ---                    | --- --        | --- -- |  
| git push origin HEAD | запушить Head | |  
| git cat-file           | Информация о содержимом из репозитория | |  
|-- ---                    | --- --        | --- -- |  
| хэш-функция          | для задонного ввода - один и тот же вывод | |  
|-- ---                    | --- --        | --- -- |  
| git diff                 | Выводит изменения из рабочего каталога | |  
| -- ---                   | --- --        | --- -- |  
| git add somefile     | добавить somefile в отслеживаемые файлы  | |   
| -- ---                   | --- --        | --- -- |  
| git ls-giles --stage | определение хэш - кодов для организованных файлов | |  
| -- ---                   | --- --        | --- -- |  
| git rm                   | удалить файл  | |  
| -- ---                   | --- --        | --- -- |  
| git mv                  | переименовать файл | |  
| -- ---                   | --- --        | --- -- |  
| !                           | Инвертация смысла шаблона | |  
| -- ---                   | --- --        | --- -- |  
| git commit all      | авто подготовка всех файлов (кроме пустых) | |  
| -- ---                   | --- --        | --- -- |  
| git commit          | создать коммит| |
| git branch           | создать ветку | git branch newImage, where newImage - name this ветки |
| git checkout       | переключиться на ветку | git checkout newImage |  
| git checkout -b [yourbrachname] | создать ветку и переключиться на нее | git checkout -b newImage |
| git merge           | слияние или мердж двух веток |  находясь в ветке main вводим  git merge newImage и получаем слияние, внизу оказывается main. Смерджим ветку `main` в ветку `bugFix`:  git checkout bugFix; git merge main |
| git rebase         | слиянение  двух веток, но с более чистой историей, будет выглядеть будто действия делались последовательно  | находясь в ветке bugFix вводим git rebase, копия bugFix встанет в одну линию под main |
| HEAD                | символическое имя текущего коммита  | |
| ^   каретка       |  перемещение на один коммит назад | git checkout main^ , git checkout main^^ , ... |
| ~num> тильда |  перемещение на несколько коммитов назад  | git checkout HEAD~4 |
| git branch -f main HEAD~3 | переместит (принудительно) ветку `main` на три родителя назад от `HEAD`, branch forcing | |
| git reset           | отменяет изменения, перенося ссылку на ветку назад, на более старый коммит, для локальной ветки | git reset HEAD~1 | 
| git revert          | Чтобы отменить изменения и поделиться отменёнными изменениями с остальными | git revert HEAD, создастся копия коммита, для удаленной ветки  | 
| `git cherry-pick Commit1> Commit2> <...>` |  создание копий от места где мы находимся | находимся в main, вводим git cherry pick C2 C4, создаются их копии и встают под main |
| git rebase -i HEAD~4 | Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе. -   Можно "выкинуть" коммит из ребейза. Для этого есть `pick` - переключение его означает, что нужно выкинуть коммит. Наконец, можно соединить коммиты. | GIT копирует эти коммиты и расставляет в новой ветке в указанном порядке или под первым аргументов(коммитом)  |
| git tag nameTag hash> | основная задача – ссылаться постоянно на конкретный коммит. | git tag v1 C1, Если конкретный коммит не указан, гит пометит тегом `HEAD`. |
| git describe     | команда, которая показывает, как далеко текущее состояние от ближайшего тега. git describe ref>, `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`). вывод команыды:  <tag>_<numCommits>_g<hash>, Где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается.| git describe main |
| git clone | команда, которая создаст _локальную_ копию удалённого репозитория | |
| git fetch | извлекать данные _из_ удалённого репозитория, связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет,  должны появиться ссылки на все ветки из этого удалённого репозитория| |
| git pull | `git fetch` и последующее слияние (merging) скаченной ветки. | |
| git fakeTeamwork |  обновить удаленный репозиторий | git fakeTeamwork nameVetki> num> В данной команде вам доступна возможность указать ветку и количество добавляемых коммитов|
| git push |  "публикацию" своей работы | |
 |git pull --rebase |  fetch и rebase | |
| git checkout -b foo o/main; git pull or git push | отслеживание ветки o/main |  |
| git branch -u | отслеживать удалённую ветку | git branch -u o/main foo |
| git push >удалённый_репозиторий> >целевая_ветка> | _Перейди в ветку с именем "main" в моём локальном репозитории, возьми все коммиты и затем перейди на ветку "main" на удалённом репозитории "origin.". На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь. | git push origin main |
| git push origin ''<источник>:<получатель>'' |  | git push origin foo^:main |
| | Git отправится в ветку `foo` на удалённом репозитории, соберёт с собой все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием `o/foo`. | git fetch origin foo |
| удалили ветку `side` в удаленном репозитории, попытавшить протолкнуть(git push) в неё "ничего".| можете оставить пустым параметр `<источник>` для команд git push и git fetch: | -   `git push origin :side` |
| git fetch origin :bar |  создасть ветку bar | |